# 1.Algorithm

Problems 883. [Projection Area of 3D Shapes](https://leetcode.com/problems/projection-area-of-3d-shapes/)

```java
class Solution {
    public int projectionArea(int[][] grid) {
        int N = grid.length;
        int ans = 0;
        for(int i = 0 ; i < N ; i++){
            int maxRow = 0;
            int maxCol = 0;
            for(int j = 0 ; j < N ; j++){
                //判断grid[i][j]是否存在cube
                if(grid[i][j] > 0)ans++;
                //判断grid[i][j]在xz面的最大值
                maxRow = Math.max(maxRow, grid[i][j]);
                //判断grid[j][i]在yz面的最大值
                maxCol = Math.max(maxCol, grid[j][i]);
            }
         	//
            ans += maxRow + maxCol;
        }
        return ans;
    }
    //https://leetcode.com/problems/projection-area-of-3d-shapes/solution/
}
```

题目的说明不是太好，熟悉时``gird[ i ][ j ]``分别对应哪个输入，它没有描述清楚。

举例说明

1. 如果是[2]，那么所处位置为grid[0,0],xy:1,xz:2,yz:2 ，总面积为5
2. 如果是[[1,2],[3,4]]，那么所处位置为grid[0,0],gird[0,1],grid[1,0],grid[1,1]，如下图

| row/column | 0    | 1    |
| ---------- | ---- | ---- |
| 0          | 1    | 2    |
| 1          | 3    | 4    |

xy对应grid[i,j]上的值是否大于0: 4

xz对应grid[i,j]的i上最大的值:2和4

yz对应grid[j,i]的j上最大的值:3和4



如果是一个N * M的grid，那么现在的这个算法就会出现溢出，因为N和M不一定是相等的。

有一个简单粗暴的解决方法就是，直接再来一个for * for循环来寻找gird[M,N]的最大值，当然是以牺牲效率的方式。



这道题目参考了leetcode的solution，感觉解法很简单但是很精简。

两个for循环，n的大小为grid.length。

时间复杂度：O(n^2)



Problems 977. [Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)

```java
class Solution {
    public int[] sortedSquares(int[] A) {
        for(int i = 0 ; i < A.length ;i++){
            A[i]  = A[i] * A[i];
        }
        Arrays.sort(A);
        return A;
    }
}
```

这道题很简单了，直接平方后代入就好了。

for循环复杂度为n(n为A.length),Arrays.sort复杂度为 nlog(n)

时间复杂度为:O(nlog(n))



Problems 979. [Distribute Coins in Binary Tree](https://leetcode.com/problems/distribute-coins-in-binary-tree/)

```java
class Solution {
    int ans;
    public int distributeCoins(TreeNode root) {
        ans = 0;
        dfs(root);
        return ans;
    }
    public int dfs(TreeNode node){
        if(node == null) return 0;
        int L = dfs(node.left);
        int R = dfs(node.right);
        //number of steps
        ans += Math.abs(L) + Math.abs(R);
        //如果leaf有0个coins，那么就需要1个coins
        //如果leaf上有多于1的coins，那么就剩余3个coins，还需要把这三个coins从这个leaf中移除开来，moves的数量为它的parent的多余数：coins-1的绝对值
        return node.val + L + R -1;
    }
   // https://leetcode.com/problems/distribute-coins-in-binary-tree/solution/
}
```

[Approach 1: Depth First Search](https://leetcode.com/problems/distribute-coins-in-binary-tree/solution/)

**Intuition**

If the leaf of a tree has 0 coins (an excess of -1 from what it needs), then we should push a coin from its parent onto the leaf. If it has say, 4 coins (an excess of 3), then we should push 3 coins off the leaf. In total, the number of moves from that leaf to or from its parent is  excess = Math.abs(num_coins - 1). Afterwards, we never have to consider this leaf again in the rest of our calculation.

1. 如果leaf有0个coins，那么就需要1个coins
2. 如果leaf上有多于1的coins，那么就剩余3个coins，还需要把这三个coins从这个leaf中移除开来，moves的数量为它的parent的多余数：coins-1的绝对值

[这个人](https://leetcode.com/awice/)是天才吗？凭感觉就能写出代码。。。

![alt text](https://github.com/MarsForever/MarsForever_ARTS/blob/master/image/week31-algorithm979.jpeg)

"In total, the number of moves from that leaf to or from its parent is excess = Math.abs(num_coins - 1)". Can somebody explain this statement? I dont understand why this is the case.



e.g. left child node has value 3, then it should give away 2 to its parent node to reach 1. So the move=2; if it has value -1, it should gain 2 from its parent node to reach 1, then the move=|-1-1|=|-2|=2. Count the number of moves passed through nodes once for every two adjancet nodes.





# 2.Review


# 3.Tip


# 4.Share