# 1.Algorithm

[852. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/)
https://github.com/MarsForever/LeetCodeForJava/blob/master/src/Solutions/Solution852.java

[938. Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)
https://github.com/MarsForever/LeetCodeForJava/blob/master/src/Solutions/Solution938.java

> 给定二叉搜索树的根结点，返回所有值在L和R之间（包括）的和。
二叉搜索树保证具有唯一值。

```java
int ans;
	public int rangeSumBST(TreeNode root, int L, int R) {
        ans = 0;
        dfs(root, L, R);
        return ans;
    }

    public void dfs(TreeNode node, int L, int R) {
        if (node != null) {
            if (L <= node.val && node.val <= R)
                ans += node.val;
            if (L < node.val)
                dfs(node.left, L, R);
            if (node.val < R)
                dfs(node.right, L, R);
        }
    }
```
参考了leetcode的solution，这个算法用了递归，所以速度是不用质疑的。但是如果这个二叉树的处理所用的 
空间超出了所定范围，那么结果就是溢出错误了。所幸如下所写，它只有1000个数，并且所得的和也不超过int的最大值2^31。 

>The number of nodes in the tree is at most 10000.
The final answer is guaranteed to be less than 2^31.

算法也算简单，if文判断是否为null，如果是null就跳过下面的处理。如果是在R和L之间，那么就加入，如果小于L或者大于R那么就继续搜索以下的值。
这个解法运用到了广度优先搜索（Breadth-First-Search） 
## 时间和空间复杂度 
*1 时间复杂度为 O(|V| + |E|) V和E分别为顶点和边。边的数目在O(1)和O(V^2)之间，取决于输入的图的稀疏。如果深度太深的话，那么它的处理速度就会变慢。

*1 [Breadth-first search ](https://www.wikiwand.com/en/Breadth-first_search)
# 2.Review


# 3.Tip


# 4.Share
##【关于日志的那些事儿】
耗子蜀黍上周布置了一个作业，让大家写日志方面的文章，也就是[Logging](https://www.wikiwand.com/en/Logging),当然此`Logging`非彼`Logging`。
[本周的“命题作文“——【关于日志的那些事儿】](https://mntfun.slack.com/archives/CBDA5RQHG/p1541665879069000)
>提示一下，
>- 日志有访问日志，行为日志……不同类型的日志有不同的格式，
>- 另外，还有日志的滚动归档，还有像systemd/syslog等这样的系统日志系统……
>*目标是一篇“引经据典“的，“全面系统“的对日志的介绍！*

日志等级分类 [code-to-logging-ratio](https://stackoverflow.com/questions/153524/code-to-logging-ratio#153547)
### INFO Level
- 方法的开始和结束
- 主要循环的开始和结束
- case/switch 语句的开始

### DEBUG Level
- 任何进入方法的变量
- 获得的结果中的每个行数
- 数据行中传到方法中的所包含的可疑数据
- 每个连接字串符或者由环境所拼凑成的生成的路径

### ERROR Level
- 异常处理
- 无效的登陆尝试（如果安全出现了问题）
- 拦截报告的错误数据

### FATAL Level
- 未处理的异常



这篇文章则提出了另外一个观点[The Problem With Logging](https://blog.codinghorror.com/the-problem-with-logging/)，因为他的日志记录策略而导致了日志锁定，而且每天至少发生一次。 
他在这次经历中惨痛地认识到

- 过多的日志代码意味着过多的代码，混乱的日志代码将应用程序代码变得难以理解
- 日志框架虽然有效但是日志记录会夺走系统的资源
- 真正值得保存的日志文件，应当在用户界面中出现，而不是隐藏起来只有管理员能看到
- 多即使少。日志文件越多，则找到的有用的信息则越少越难

定义好什么是`INFO`,`DEBUG`,`ERROR`,`FATAL`这样才会避免日志记录带来的负面影响。

[Logging Cheat Sheet](https://www.owasp.org/index.php/Logging_Cheat_Sheet#Introduction)根据日志的目的，设计和实施来说明如何设计一个有效的日志。主要针对web日志，它提出了几个很有意思的观点，`when` `where` `who` `what`

- when

  - 记录日期和时间
  - 事件日期和时间，事件的时间戳可能和记录时间不一样
  - 交互标识符，链接单个用户交互的所有相关事件的方法

- Where

  - 特定应用 比如应用名和版本
  - 应用的地址，主机或群集名，服务器的IPv4或IPv6的地址和端口号,工作站标识，本地设备标识符
  - 服务名和协议
  - 地理定位
  - 窗口/表单/页面 比如网页应用的入口网址和http方法，对话框名称
  - 代码位置 比如脚本名，模块名

- Who（人或机器）

  - 代码位置 比如用户的设备/机器识别符，用户的ip地址，基站，射频转接塔ID，移动手机号码
  - 用户身份（已通过身份验证或者通过其他方式得知），比如用户的数据库中的主键值，用户名，许可证号码

- What

  - 事件类型 每个团体都应该有一个一致的记录事件的分类方法（类型，可信度，严重性）
  - 事件的严重性 比如{0=emergency, 1=alert, ..., 7=debug}, {fatal, error, warning, info, debug, trace}
  - 安全相关事件标识（即使事件本身不包含有关安全的事件数据）
  - 描述


不应该包含在日志中的数据，应该要被删除，清理，屏蔽，清理，哈希值化或加密

  - 应用程序源代码
  - 会话识别值（如果需要标识出会话的特定事件应该考虑替换成哈希值）
  - 访问令牌
  - 敏感的个人信息或者是某种形式的个人可识别信息，比如健康状况，身份证号，弱势群体
  - 验证码
  - 数据库连接字符串
  - 加密密钥和其他主要的隐秘信息
  - 银行账号或者支付卡持有人的数据
  - 允许储存比日志系统更高安全级别的数据
  - 商业敏感信息
  - 非法收集相关的司法管辖区信息
  - 用户选择退出收集或者未同意使用跟踪信息，或收集的信息本身同意期限已过期

 几个主要的Java[日志框架](https://www.wikiwand.com/en/Java_logging_framework)有

- log4j
- slf4j
- Java Logging API
- Apache Commons Logging
- tinylog
- Logback

其中[`log4j`](http://commons.apache.org/proper/commons-logging/)和[`slf4j`](https://www.slf4j.org/)应该是最被广泛使用的日志框架。

因为`slf4j`是在抽象层，所以`log4j`和`slf4j`有可能同时使用

另外关于日志的可缩放可以参考`Netfilex`  的这篇文章[Scalable Logging and Tracking](https://medium.com/netflix-techblog/scalable-logging-and-tracking-882bde0ddca2)。