# 1.Algorithm

[852. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/)
https://github.com/MarsForever/LeetCodeForJava/blob/master/src/Solutions/Solution852.java

[D938. Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)
> 给定二叉搜索树的根结点，返回所有值在L和R之间（包括）的和。
二叉搜索树保证具有唯一值。

```java
int ans;
	public int rangeSumBST(TreeNode root, int L, int R) {
        ans = 0;
        dfs(root, L, R);
        return ans;
    }

    public void dfs(TreeNode node, int L, int R) {
        if (node != null) {
            if (L <= node.val && node.val <= R)
                ans += node.val;
            if (L < node.val)
                dfs(node.left, L, R);
            if (node.val < R)
                dfs(node.right, L, R);
        }
    }
```
参考了leetcode的solution，这个算法用了递归，所以速度是不用质疑的。但是如果这个二叉树的处理所用的 
空间超出了所定范围，那么结果就是溢出错误了。所幸如下所写，它只有1000个数，并且所得的和也不超过int的最大值2^31。 

>The number of nodes in the tree is at most 10000.
The final answer is guaranteed to be less than 2^31.

算法也算简单，if文判断是否为null，如果是null就跳过下面的处理。如果是在R和L之间，那么就加入，如果小于L或者大于R那么就继续搜索以下的值。
这个解法运用到了广度优先搜索（Breadth-First-Search） 
## 时间和空间复杂度 
*1 时间复杂度为 O(|V| + |E|) V和E分别为顶点和边。边的数目在O(1)和O(V^2)之间，取决于输入的图的稀疏。如果深度太深的话，那么它的处理速度就会变慢。

*1 [Breadth-first search ](https://www.wikiwand.com/en/Breadth-first_search)
# 2.Review


# 3.Tip


# 4.Share

耗子蜀黍上周布置了一个作业，让大家写日志方面的文章，也就是[Logging](https://www.wikiwand.com/en/Logging),当然此`Logging`非彼`Logging`。
[本周的“命题作文“——【关于日志的那些事儿】](https://mntfun.slack.com/archives/CBDA5RQHG/p1541665879069000)
>提示一下，
>- 日志有访问日志，行为日志……不同类型的日志有不同的格式，
>- 另外，还有日志的滚动归档，还有像systemd/syslog等这样的系统日志系统……
>*目标是一篇“引经据典“的，“全面系统“的对日志的介绍！*

日志等级分类 [code-to-logging-ratio](https://stackoverflow.com/questions/153524/code-to-logging-ratio#153547)
## INFO Level
- 方法的开始和结束
- 主要循环的开始和结束
- case/switch 语句的开始

## DEBUG Level
- 任何进入方法的变量
- 获得的结果中的每个行数
- 数据行中传到方法中的所包含的可疑数据
- 每个连接字串符或者由环境所拼凑成的生成的路径

## ERROR Level
- 异常处理
- 无效的登陆尝试（如果安全出现了问题）
- 拦截报告的错误数据

## FATAL Level
- 未处理的异常

这篇文章则提出了另外一个观点[The Problem With Logging](https://blog.codinghorror.com/the-problem-with-logging/)，因为他的日志记录策略而导致了日志锁定，而且每天至少发生一次。 
他在这次经历中惨痛地认识到
- 过多的日志代码意味着过多的代码，混乱的日志代码将应用程序代码变得难以理解
- 日志框架虽然有效但是日志记录会夺走系统的资源
- 真正值得保存的日志文件，应当在用户界面中出现，而不是隐藏起来只有管理员能看到
- 多即使少。日志文件越多，则找到的有用的信息则越少越难

最后的总结是定义好什么是`INFO`,`DEBUG`,`ERROR`,`FATAL`这样才会避免日志记录带来的负面影响。

[Logging Cheat Sheet](https://www.owasp.org/index.php/Logging_Cheat_Sheet#Introduction)
[Scalable Logging and Tracking](https://medium.com/netflix-techblog/scalable-logging-and-tracking-882bde0ddca2)
