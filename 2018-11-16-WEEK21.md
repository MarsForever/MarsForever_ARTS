# 1.Algorithm

[852. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/)
https://github.com/MarsForever/LeetCodeForJava/blob/master/src/Solutions/Solution852.java

[D938. Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)
> 给定二叉搜索树的根结点，返回所有值在L和R之间（包括）的和。
二叉搜索树保证具有唯一值。

```java
int ans;
	public int rangeSumBST(TreeNode root, int L, int R) {
        ans = 0;
        dfs(root, L, R);
        return ans;
    }

    public void dfs(TreeNode node, int L, int R) {
        if (node != null) {
            if (L <= node.val && node.val <= R)
                ans += node.val;
            if (L < node.val)
                dfs(node.left, L, R);
            if (node.val < R)
                dfs(node.right, L, R);
        }
    }
```
参考了leetcode的solution，这个算法用了递归，所以速度是不用质疑的。但是如果这个二叉树的处理所用的 
空间超出了所定范围，那么结果就是溢出错误了。所幸如下所写，它只有1000个数，并且所得的和也不超过int的最大值2^31。 

>The number of nodes in the tree is at most 10000.
The final answer is guaranteed to be less than 2^31.

算法也算简单，if文判断是否为null，如果是null就跳过下面的处理。如果是在R和L之间，那么就加入，如果小于L或者大于R那么就继续搜索以下的值。
这个解法运用到了广度优先搜索（Breadth-First-Search） 
## 时间和空间复杂度 
*1 时间复杂度为 O(|V| + |E|) V和E分别为顶点和边。边的数目在O(1)和O(V^2)之间，取决于输入的图的稀疏。如果深度太深的话，那么它的处理速度就会变慢。

*1 [Breadth-first search ](https://www.wikiwand.com/en/Breadth-first_search)
# 2.Review


# 3.Tip


# 4.Share

耗子蜀黍上周布置了一个作业，让大家写日志方面的文章，也就是[Logging](https://www.wikiwand.com/en/Logging),当然此`Logging`非彼`Logging`。
[本周的“命题作文“——【关于日志的那些事儿】](https://mntfun.slack.com/archives/CBDA5RQHG/p1541665879069000)
>提示一下，
>- 日志有访问日志，行为日志……不同类型的日志有不同的格式，
>- 另外，还有日志的滚动归档，还有像systemd/syslog等这样的系统日志系统……
>*目标是一篇“引经据典“的，“全面系统“的对日志的介绍！*

[The Problem With Logging](https://blog.codinghorror.com/the-problem-with-logging/)
[Logging Cheat Sheet](https://www.owasp.org/index.php/Logging_Cheat_Sheet#Introduction)
[Scalable Logging and Tracking](https://medium.com/netflix-techblog/scalable-logging-and-tracking-882bde0ddca2)
