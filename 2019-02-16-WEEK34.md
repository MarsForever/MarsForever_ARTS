# 1.Algorithm

Problems 986. [Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/)
```java
class Solution {
    public Interval[] intervalIntersection(Interval[] A, Interval[] B) {
        Interval aws[] = new Interval[A.length * B.length];
        int index = 0;
        for(int i = 0 ; i < A.length ; i++){
            for(int j = 0 ; j < B.length ; j++){
                if(B[j].start > A[i].end || A[i].start > B[j].end ){
                    continue;
                }else{
                    aws[index]=new Interval(Math.max(A[i].start,B[j].start),Math.min(A[i].end, B[j].end));
                    index++;
                }
            }
        }
        Interval returnAws[] = Arrays.copyOf(aws, index);
        
        return returnAws;
    }
}


/*
Runtime: 43 ms, faster than 13.75% of Java online submissions for Interval List Intersections.
Memory Usage: 51.9 MB, less than 100.00% of Java online submissions for Interval List Intersections.
*/
```

因为这次涉及到Constructor的Array初始化数据，所以参考了下面的link。

https://stackoverflow.com/questions/10456681/how-to-initialize-array-in-java-when-the-class-constructor-has-parameters

核心代码参考下面的的link，没有理解直接用了，不是什么好习惯。

https://scicomp.stackexchange.com/questions/26258/the-easiest-way-to-find-intersection-of-two-intervals

把多余的null都给去掉，参考了下面的代码。

```java
int[] a = new int[5]{1,2,3,4,5};
int[] b = Arrays.copyOf(a, a.length);
```

https://stackoverflow.com/questions/5785745/make-copy-of-an-array



其实还是有优化的空间的。

# 2.Review


# 3.Tip


# 4.Share